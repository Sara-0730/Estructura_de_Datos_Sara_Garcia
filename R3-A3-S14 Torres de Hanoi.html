<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torres de Hanoi - Solución Recursiva</title>
    <style>
        /* Estilos generales */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        /* Estilos para los controles */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            background-color: #8572c9;
            color: white;
            border: none;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #8572c9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        label {
            display: flex;
            align-items: center;
            font-weight: bold;
        }

        select, input {
            padding: 8px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            margin-left: 10px;
        }

        /* Estilos para las torres */
        .towers-container {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
        }

        .tower {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            position: relative;
            height: 300px;
            width: 200px;
        }

        .tower-base {
            width: 180px;
            height: 15px;
            background-color:#585858;
            border-radius: 5px;
            margin-top: 10px;
        }

        .tower-rod {
            position: absolute;
            width: 15px;
            height: 280px;
            background-color: #585858;
            bottom: 15px;
            z-index: 1;
            border-radius: 5px 5px 0 0;
        }

        .tower-label {
            font-weight: bold;
            margin-top: 20px;
            font-size: 18px;
            color: #2c3e50;
        }

        .disc-container {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            height: 280px;
            width: 180px;
            position: absolute;
            bottom: 25px;
        }

       .disc {
    height: 25px;
    border-radius: 15px;
    margin-bottom: 4px;
    transition: all 0.5s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #2d3436; /* texto oscuro para buen contraste */
    font-weight: 600;
    z-index: 2;
}

/* Colores para los discos según su tamaño */
.disc.size-1 { background-color: #ff7675; }   /* rojo pastel */
.disc.size-2 { background-color: #fab1a0; }   /* durazno suave */
.disc.size-3 { background-color: #ffeaa7; }   /* amarillo pastel */
.disc.size-4 { background-color: #55efc4; }   /* verde menta claro */
.disc.size-5 { background-color: #74b9ff; }   /* azul cielo suave */
.disc.size-6 { background-color: #a29bfe; }   /* lila suave */
.disc.size-7 { background-color: #dfe6e9; color: #636e72; } /* gris claro con texto gris oscuro */


        /* Estadísticas y logs */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .stat-box {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 30%;
            min-width: 250px;
            margin-bottom: 20px;
        }

        .stat-box h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        .log-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .log-entry {
            margin-bottom: 5px;
            font-family: monospace;
        }

        /* Explicación */
        .explanation {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 30px;
        }

        .explanation h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        code {
            background-color: #f7f7f7;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Velocidad */
        .speed-container {
            display: flex;
            align-items: center;
        }

        #speed-value {
            margin-left: 10px;
            font-weight: bold;
            width: 30px;
            text-align: center;
        }

        /* Responsivo */
        @media (max-width: 768px) {
            .towers-container {
                flex-direction: column;
                align-items: center;
            }
            
            .tower {
                margin-bottom: 50px;
            }
            
            .stats {
                flex-direction: column;
                align-items: center;
            }
            
            .stat-box {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <h1>Torres de Hanoi - Solución Recursiva</h1>
    
    <div class="controls">
        <label for="discs">Número de discos: 
            <select id="discs">
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
            </select>
        </label>
        
        <div class="speed-container">
            <label for="speed">Velocidad: 
                <input type="range" id="speed" min="1" max="10" value="5">
            </label>
            <span id="speed-value">5</span>
        </div>
        
        <button id="start-btn">Iniciar</button>
        <button id="reset-btn">Reiniciar</button>
        <button id="step-btn" disabled>Paso a paso</button>
    </div>

    <div class="towers-container">
        <div class="tower-label">Torre A (Origen)</div>
        <div class="tower">
            <div class="tower-rod"></div>
            <div class="disc-container" id="tower-a"></div>
            <div class="tower-base"></div>
            
        </div>
         <div class="tower-label">Torre B (Auxiliar)</div>
        <div class="tower">
            <div class="tower-rod"></div>
            <div class="disc-container" id="tower-b"></div>
            <div class="tower-base"></div>
           
        </div>
         <div class="tower-label">Torre C (Destino)</div>
        <div class="tower">
            <div class="tower-rod"></div>
            <div class="disc-container" id="tower-c"></div>
            <div class="tower-base"></div>
           
        </div>
    </div>

    <div class="stats">
        <div class="stat-box">
            <h3>Estadísticas</h3>
            <p>Número de discos: <span id="disc-count">3</span></p>
            <p>Movimientos realizados: <span id="moves-count">0</span></p>
            <p>Movimientos mínimos necesarios: <span id="min-moves">7</span></p>
        </div>
        
        <div class="stat-box">
            <h3>Llamadas recursivas</h3>
            <p>Total de llamadas recursivas: <span id="recursive-calls">0</span></p>
            <p>Profundidad máxima: <span id="max-depth">0</span></p>
        </div>
        
        <div class="stat-box">
            <h3>Registro de movimientos</h3>
            <div class="log-container" id="move-log"></div>
        </div>
    </div>

    <div class="explanation">
        <h2>Explicación del algoritmo recursivo</h2>
        <p>El problema de las Torres de Hanoi consiste en mover n discos desde una torre origen a una torre destino, usando una torre auxiliar, siguiendo estas reglas:</p>
        <ol>
            <li>Solo se puede mover un disco a la vez.</li>
            <li>Nunca puede haber un disco más grande encima de uno más pequeño.</li>
        </ol>
        <p>El algoritmo recursivo para resolver este problema se basa en la siguiente idea:</p>
        <ol>
            <li>Mover (n-1) discos desde la torre origen a la torre auxiliar, usando la torre destino como auxiliar.</li>
            <li>Mover el disco n (el más grande) desde la torre origen a la torre destino.</li>
            <li>Mover los (n-1) discos desde la torre auxiliar a la torre destino, usando la torre origen como auxiliar.</li>
        </ol>
        <p>La función recursiva que implementa esta solución es:</p>
        <pre><code>/**
 * Función recursiva que resuelve las Torres de Hanoi
 * @param {number} n - Número de discos a mover
 * @param {string} origen - Torre de origen
 * @param {string} auxiliar - Torre auxiliar
 * @param {string} destino - Torre de destino
 * @param {number} depth - Profundidad de la recursión actual
 */
function hanoi(n, origen, auxiliar, destino, depth = 0) {
    // Incrementamos el contador de llamadas recursivas
    recursiveCalls++;
    
    // Actualizamos la profundidad máxima de recursión
    maxDepth = Math.max(maxDepth, depth);
    
    // Caso base: si solo hay un disco, lo movemos directamente al destino
    if (n === 1) {
        // Añadir el movimiento a la lista de movimientos
        moves.push({
            disc: 1,
            from: origen,
            to: destino
        });
        return;
    }
    
    // Paso 1: Mover (n-1) discos de origen a auxiliar usando destino como auxiliar
    hanoi(n - 1, origen, destino, auxiliar, depth + 1);
    
    // Paso 2: Mover el disco n de origen a destino
    moves.push({
        disc: n,
        from: origen,
        to: destino
    });
    
    // Paso 3: Mover (n-1) discos de auxiliar a destino usando origen como auxiliar
    hanoi(n - 1, auxiliar, origen, destino, depth + 1);
}</code></pre>
    </div>

    <script>
        // Variables globales
        let discCount = 3; // Número de discos
        let towers = {
            'A': [], // Torre origen
            'B': [], // Torre auxiliar
            'C': []  // Torre destino
        };
        let moves = []; // Movimientos calculados
        let currentMove = 0; // Índice del movimiento actual
        let isAnimating = false; // Indica si hay una animación en curso
        let autoMode = true; // Modo automático o paso a paso
        let animationSpeed = 5; // Velocidad de la animación (1-10)
        let recursiveCalls = 0; // Contador de llamadas recursivas
        let maxDepth = 0; // Profundidad máxima de recursión
        
        // Referencias a elementos del DOM
        const discSelect = document.getElementById('discs');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const stepBtn = document.getElementById('step-btn');
        const speedSlider = document.getElementById('speed');
        const speedValue = document.getElementById('speed-value');
        const towerA = document.getElementById('tower-a');
        const towerB = document.getElementById('tower-b');
        const towerC = document.getElementById('tower-c');
        const discCountSpan = document.getElementById('disc-count');
        const movesCountSpan = document.getElementById('moves-count');
        const minMovesSpan = document.getElementById('min-moves');
        const recursiveCallsSpan = document.getElementById('recursive-calls');
        const maxDepthSpan = document.getElementById('max-depth');
        const moveLog = document.getElementById('move-log');
                
        // Colores para los discos (del más pequeño al más grande)
        const discColors = [
            '#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', 
            '#1abc9c', '#3498db', '#9b59b6', '#8e44ad'
        ];
        
        /**
         * Inicializa el juego de las Torres de Hanoi
         */
        function initGame() {
            // Limpiar torres
            towers = { 'A': [], 'B': [], 'C': [] };
            
            // Limpiar elementos visuales
            towerA.innerHTML = '';
            towerB.innerHTML = '';
            towerC.innerHTML = '';

            discCount = parseInt(discSelect.value);
            
            // Llenar la torre de origen con discos
            for (let i = discCount; i >= 1; i--) {
                towers['A'].push(i);
                createDisc(i, towerA);
            }
            
            // Actualizar estadísticas
            discCountSpan.textContent = discCount;
            movesCountSpan.textContent = '0';
            const minMoves = Math.pow(2, discCount) - 1;
            minMovesSpan.textContent = minMoves;
            
            // Reiniciar variables
            moves = [];
            currentMove = 0;
            recursiveCalls = 0;
            maxDepth = 0;
            recursiveCallsSpan.textContent = '0';
            maxDepthSpan.textContent = '0';
            moveLog.innerHTML = '';
            
            // Habilitar/deshabilitar botones
            startBtn.disabled = false;
            stepBtn.disabled = true;
        }
        
        /**
         * Crea un elemento visual de disco
         * @param {number} size - Tamaño del disco (1 es el más pequeño)
         * @param {HTMLElement} tower - Torre donde se añadirá el disco
         */
        function createDisc(size, tower) {
            const disc = document.createElement('div');
            disc.className = 'disc';
            disc.setAttribute('data-size', size);
            
            // Calcular el ancho basado en el tamaño
            const width = 40 + (size * 15);
            disc.style.width = `${width}px`;
            disc.style.backgroundColor = discColors[size - 1];
            disc.textContent = size;
            
            tower.appendChild(disc);
        }
        
        /**
         * Calcula todos los movimientos necesarios usando el algoritmo recursivo
         * e inicia la animación
         */
        function calculateMoves() {
            // Reiniciar contadores
            recursiveCalls = 0;
            maxDepth = 0;
            moves = [];
            
            // Calcular movimientos usando el algoritmo recursivo
            hanoi(discCount, 'A', 'B', 'C');
            
            // Actualizar estadísticas
            recursiveCallsSpan.textContent = recursiveCalls;
            maxDepthSpan.textContent = maxDepth;
            
            // Iniciar animación en modo automático o preparar para paso a paso
            if (autoMode) {
                animateAllMoves();
            } else {
                stepBtn.disabled = false; // Habilitamos el botón paso a paso
            }
        }
        
        /**
         * Función recursiva que resuelve las Torres de Hanoi
         * @param {number} n - Número de discos a mover
         * @param {string} origen - Torre de origen
         * @param {string} auxiliar - Torre auxiliar
         * @param {string} destino - Torre de destino
         * @param {number} depth - Profundidad de la recursión actual
         */
        function hanoi(n, origen, auxiliar, destino, depth = 0) {
            // Incrementamos el contador de llamadas recursivas
            recursiveCalls++;
            
            // Actualizamos la profundidad máxima de recursión
            maxDepth = Math.max(maxDepth, depth);
            
            // Caso base: si solo hay un disco, lo movemos directamente al destino
            if (n === 1) {
                // Añadir el movimiento a la lista de movimientos
                moves.push({
                    disc: 1,
                    from: origen,
                    to: destino
                });
                return;
            }
            
            // Paso 1: Mover (n-1) discos de origen a auxiliar usando destino como auxiliar
            hanoi(n - 1, origen, destino, auxiliar, depth + 1);
            
            // Paso 2: Mover el disco n de origen a destino
            moves.push({
                disc: n,
                from: origen,
                to: destino
            });
            
            // Paso 3: Mover (n-1) discos de auxiliar a destino usando origen como auxiliar
            hanoi(n - 1, auxiliar, origen, destino, depth + 1);
        }
        
        /**
         * Anima todos los movimientos calculados de forma secuencial
         */
        function animateAllMoves() {
            if (currentMove >= moves.length || isAnimating) {
                return;
            }
            
            // Realizar el movimiento actual
            isAnimating = true;
            executeMove(moves[currentMove], () => {
                currentMove++;
                isAnimating = false;
                
                // Si hay más movimientos, continuar la animación después de un tiempo
                if (currentMove < moves.length) {
                    // Calcular el tiempo de espera basado en la velocidad
                    const delay = Math.max(1000 - (animationSpeed * 90), 100);
                    setTimeout(animateAllMoves, delay);
                }
            });
        }
        
        /**
         * Ejecuta un solo movimiento y actualiza la representación visual
         * @param {Object} move - Objeto que describe el movimiento
         * @param {function} callback - Función a llamar al completar el movimiento
         */
        function executeMove(move, callback) {
            // Obtener las torres de origen y destino
            const fromTower = document.getElementById(`tower-${move.from.toLowerCase()}`);
            const toTower = document.getElementById(`tower-${move.to.toLowerCase()}`);
            
            // Obtener el disco a mover (último elemento de la torre de origen)
            const disc = fromTower.lastElementChild;
            
            if (!disc) {
                console.error('No hay disco para mover:', move);
                if (callback) callback();
                return;
            }
            
            // Actualizar el modelo de datos
            const discSize = parseInt(disc.getAttribute('data-size'));
            towers[move.from].pop();
            towers[move.to].push(discSize);
            
            // Mover el disco al final de la torre de destino
            toTower.appendChild(disc);
            
            // Registrar el movimiento en el log
            logMove(move.disc, move.from, move.to);
            
            // Actualizar contador de movimientos
            movesCountSpan.textContent = (currentMove + 1);
            
            // Llamar al callback cuando la transición CSS termine
            setTimeout(() => {
                if (callback) callback();
            }, 500); // Debe coincidir con la duración de la transición CSS
        }
        
        /**
         * Registra un movimiento en el registro visual
         * @param {number} disc - Tamaño del disco
         * @param {string} from - Torre de origen
         * @param {string} to - Torre de destino
         */
        function logMove(disc, from, to) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `Mover disco ${disc} de Torre ${from} a Torre ${to}`;
            moveLog.appendChild(logEntry);
            moveLog.scrollTop = moveLog.scrollHeight; // Auto-scroll al final
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', initGame);
        
        // Cambiar número de discos
        discSelect.addEventListener('change', () => {
            initGame();
        });
        
        // Iniciar resolución
        startBtn.addEventListener('click', () => {
            currentMove = 0;
            moveLog.innerHTML = '';
            
            // Determinar si es modo automático o paso a paso
            const modeSelect = confirm("¿Ejecutar en modo automático? \n- Aceptar: Animación automática \n- Cancelar: Modo paso a paso");
            autoMode = modeSelect;
            
            // Calcular los movimientos en cualquier caso
            calculateMoves();
            
            // Configurar la UI según el modo
            startBtn.disabled = true;
            stepBtn.disabled = autoMode; // Habilitamos el botón si es modo paso a paso
        });
        
        // Reiniciar
        resetBtn.addEventListener('click', () => {
            initGame();
            stepBtn.disabled = true;
        });
        
        // Modo paso a paso
        stepBtn.addEventListener('click', () => {
            if (currentMove < moves.length && !isAnimating) {
                isAnimating = true;
                executeMove(moves[currentMove], () => {
                    currentMove++;
                    isAnimating = false;
                    
                    // Deshabilitar botón si no hay más movimientos
                    if (currentMove >= moves.length) {
                        stepBtn.disabled = true;
                    }
                });
            }
        });
        
        // Control de velocidad
        speedSlider.addEventListener('input', () => {
            animationSpeed = parseInt(speedSlider.value);
            speedValue.textContent = animationSpeed;
        });
    </script>
</body>
</html>